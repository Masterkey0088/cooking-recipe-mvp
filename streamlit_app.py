# -*- coding: utf-8 -*-
# „Åî„ÅØ„Çì„ÅÆÁ•ûÊßò„Å´Áõ∏Ë´á„Å†ÔºÅ / Streamlit App
# ÊñπÂºèAÔºöSecrets„ÅÆ APP_MODE „Å´„Çà„Çä„Éô„Éº„Çø/ÈñãÁô∫„ÇíÂàáÊõø
#   - APP_MODE = "beta"  ‚Üí „Éô„Éº„ÇøÁâàÔºà„ÉÜ„Çπ„Éà„É¶„Éº„Ç∂„ÉºÂêë„Åë„ÄÅÂÆâÂÆöË®≠ÂÆöÔºâ
#   - APP_MODE = "dev"   ‚Üí ÈñãÁô∫ÁâàÔºà„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØÂèçÊò†„ÅÆÂÆüÈ®ìË®≠ÂÆöÔºâ
#   - APP_MODE = "prod"  ‚Üí Êú¨Áï™Áâà
# ÂøÖÈ†àSecrets: OPENAI_API_KEYÔºàOpenAI‰ΩøÁî®ÊôÇÔºâ„ÄÅ‰ªªÊÑè: APP_MODE, APP_ACCESS_CODE

from __future__ import annotations
import os
import re
import json
from typing import List, Optional

import streamlit as st
from pydantic import BaseModel, Field

# ------------------------------------------------------------
# App mode & feature flagsÔºàÊñπÂºèAÔºâ
# ------------------------------------------------------------
APP_MODE = (st.secrets.get("APP_MODE") or os.getenv("APP_MODE") or "beta").lower()
IS_DEV = APP_MODE in ("dev", "development")
IS_PROD = APP_MODE in ("prod", "production")

APP_TITLE = "„Åî„ÅØ„Çì„ÅÆÁ•ûÊßò„Å´Áõ∏Ë´á„Å†ÔºÅ" + ("ÔºàÈñãÁô∫ÁâàÔºâ" if IS_DEV else ("ÔºàÊú¨Áï™Ôºâ" if IS_PROD else "Ôºà„Éô„Éº„ÇøÁâàÔºâ"))
st.set_page_config(page_title=APP_TITLE, layout="wide")
st.title(f"üç≥ {APP_TITLE}")

FEATURES = {
    # ÁîªÂÉèUIÔºàÂ∞ÜÊù•ON„Å´„Åó„Åü„ÅÑÊôÇ„ÅÆ„Éï„É©„Ç∞Ôºâ‚ÄªÁèæÁä∂OFF
    "ENABLE_IMAGE_UI": False,

    # ÂìÅË≥™„Éï„Ç£„É´„ÇøÔºãËá™Âãï„É™„Éà„É©„Ç§
    "ENABLE_QUALITY_FILTER": True,
    "MAX_QUALITY_RETRY": 3 if not IS_DEV else 5,
    "KEEP_AT_LEAST_ONE": True if not IS_DEV else False,

    # „É¢„Éá„É´Ê∏©Â∫¶ÔºàÈñãÁô∫Áâà„ÅØÊé¢Á¥¢Â§ö„ÇÅÔºâ
    "TEMPERATURE": 0.4 if not IS_DEV else 0.6,

    # ÈñãÁô∫ËÄÖÂêë„Åë„Éá„Éê„ÉÉ„Ç∞
    "SHOW_DEBUG_PANEL": IS_DEV,
}

# ------------------------------------------------------------
# Ôºà‰ªªÊÑèÔºâ„Ç¢„ÇØ„Çª„Çπ„Ç≥„Éº„Éâ„É≠„ÉÉ„ÇØ
# ------------------------------------------------------------
ACCESS_CODE = st.secrets.get("APP_ACCESS_CODE") or os.getenv("APP_ACCESS_CODE")
if ACCESS_CODE:
    if not st.session_state.get("auth_ok"):
        st.info("„Åì„ÅÆ„Ç¢„Éó„É™„ÅØ„Ç¢„ÇØ„Çª„Çπ„Ç≥„Éº„Éâ„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ")
        code = st.text_input("„Ç¢„ÇØ„Çª„Çπ„Ç≥„Éº„Éâ", type="password")
        if st.button("Enter", use_container_width=True):
            if code == ACCESS_CODE:
                st.session_state["auth_ok"] = True
                st.rerun()
            else:
                st.error("„Ç¢„ÇØ„Çª„Çπ„Ç≥„Éº„Éâ„ÅåÈÅï„ÅÑ„Åæ„Åô")
                st.stop()
        st.stop()

# ============================================================
# „Éá„Éº„Çø„É¢„Éá„É´
# ============================================================
class Ingredient(BaseModel):
    name: str
    amount: Optional[str] = None
    is_optional: bool = False
    substitution: Optional[str] = None

class Step(BaseModel):
    text: str

class Recipe(BaseModel):
    recipe_title: str = Field(..., alias="title")
    servings: int = 2
    total_time_min: Optional[int] = None
    difficulty: Optional[str] = None
    ingredients: List[Ingredient]
    steps: List[Step]
    equipment: Optional[List[str]] = None

class RecipeSet(BaseModel):
    recommendations: List[Recipe]

# ============================================================
# „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£ÔºöÊâãÈ†ÜÊï¥ÂΩ¢ÔºàSTEP n Ë°®Ë®ò„Å´Áµ±‰∏ÄÔºâ
# ============================================================
_STEP_PREFIX_RE = re.compile(
    r"^\s*(?:STEP\s*[0-9Ôºê-Ôºô]+[:Ôºö\-\s]*|[0-9Ôºê-Ôºô]+[\.Ôºé„ÄÅ\)Ôºâ]\s*|[‚ë†-‚ë≥]\s*)"
)
def strip_step_prefix(text: str) -> str:
    return _STEP_PREFIX_RE.sub('', text or '').strip()

# ============================================================
# „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£ÔºöÊùêÊñô„ÅÆÂàÜÈáèÊé®ÂÆö„ÉªÊ≠£Ë¶èÂåñÔºà„ÄåÊùêÊñôÂêç Èáè„Äç„Å´Áµ±‰∏ÄÔºâ
# ============================================================
TSP_IN_TBSP = 3.0

PROTEIN_G_PER_SERV = {
    "È∂è„ÇÄ„Å≠ËÇâ": 100, "È∂è„ÇÇ„ÇÇËÇâ": 100, "Ë±öËÇâ": 100, "ÁâõËÇâ": 100, "„Å≤„ÅçËÇâ": 100,
    "ÈÆ≠": 90, "„Åï„Å∞": 90, "„ÉÑ„Éä": 70, "„Éô„Éº„Ç≥„É≥": 30, "„Éè„É†": 30, "Ë±ÜËÖê": 150
}
VEG_G_PER_SERV = {
    "Áéâ„Å≠„Åé": 50, "„Å≠„Åé": 10, "Èï∑„Å≠„Åé": 20, "„Ç≠„É£„Éô„ÉÑ": 80, "„Å´„Çì„Åò„Çì": 40,
    "„Åò„ÇÉ„Åå„ÅÑ„ÇÇ": 80, "„Å™„Åô": 60, "„Éî„Éº„Éû„É≥": 40, "„ÇÇ„ÇÑ„Åó": 100, "„Éñ„É≠„ÉÉ„Ç≥„É™„Éº": 70,
    "„Åç„ÅÆ„Åì": 60, "„Åó„ÇÅ„Åò": 60, "„Åà„ÅÆ„Åç": 60, "„Éà„Éû„Éà": 80, "ÈùíËèú": 70, "Â∞èÊùæËèú": 70, "„Åª„ÅÜ„Çå„ÇìËçâ": 70
}
COND_TSP_PER_SERV = {
    "Â°©": 0.125, "Á†ÇÁ≥ñ": 0.5, "„Åó„Çá„ÅÜ„ÇÜ": 1.0, "ÈÜ§Ê≤π": 1.0, "„Åø„Çä„Çì": 1.0, "ÈÖí": 1.0,
    "ÈÖ¢": 1.0, "„Ç≥„ÉÅ„É•„Ç∏„É£„É≥": 0.5, "Âë≥Âôå": 1.5, "Âë≥„ÅÆÁ¥†": 0.25, "È°ÜÁ≤í„Å†„Åó": 0.5
}
OIL_TSP_PER_SERV = {"„Çµ„É©„ÉÄÊ≤π": 1.0, "„Åî„ÅæÊ≤π": 0.5, "„Ç™„É™„Éº„Éñ„Ç™„Ç§„É´": 1.0}
PIECE_PER_SERV = {"Âçµ": "1ÂÄã", "„Å´„Çì„Å´„Åè": "0.5Áâá", "ÁîüÂßú": "0.5Áâá"}

_num_re = re.compile(r'([0-9]+(?:\.[0-9]+)?)')
def _has_number(s: str) -> bool:
    return bool(_num_re.search(s or ""))

def _round_tsp_to_pretty(tsp: float) -> str:
    if tsp <= 0.15:
        return "Â∞ë„ÄÖ"
    tbsp = tsp / TSP_IN_TBSP
    if tbsp >= 1.0:
        val = round(tbsp * 2) / 2  # 0.5Âàª„Åø
        return f"Â§ß„Åï„Åò{val:g}"
    else:
        val = round(tsp * 2) / 2
        return f"Â∞è„Åï„Åò{val:g}"

def _grams_to_pretty(g: int) -> str:
    if g < 60: step = 10
    elif g < 150: step = 25
    else: step = 50
    pretty = int(round(g / step) * step)
    return f"{pretty}g"

def _guess_amount(name: str, servings: int) -> str:
    for key, per in PIECE_PER_SERV.items():
        if key in name:
            m = _num_re.search(per)
            num = float(m.group(1)) if m else 1.0
            unit = per.replace(str(num).rstrip('0').rstrip('.'), '')
            total = num * servings
            if abs(total - int(total)) < 1e-6:
                return f"{int(total)}{unit}"
            return f"{total:g}{unit}"
    for key, g in PROTEIN_G_PER_SERV.items():
        if key in name:
            return _grams_to_pretty(int(g * servings))
    for key, g in VEG_G_PER_SERV.items():
        if key in name:
            return _grams_to_pretty(int(g * servings))
    for key, tsp in OIL_TSP_PER_SERV.items():
        if key in name:
            return _round_tsp_to_pretty(tsp * servings)
    for key, tsp in COND_TSP_PER_SERV.items():
        if key in name:
            return _round_tsp_to_pretty(tsp * servings)
    if any(k in name for k in ["ËÉ°Ê§í", "„Åì„Åó„Çá„ÅÜ", "ÈªíËÉ°Ê§í", "‰∏ÄÂë≥", "‰∏ÉÂë≥", "„É©„ÉºÊ≤π"]):
        return "Â∞ë„ÄÖ"
    return "ÈÅ©Èáè"

# ÊùêÊñôÂêç„ÅÆ‰∏≠„Å´Âüã„Åæ„Å£„ÅüÂàÜÈáè„ÇíÊäΩÂá∫Ôºà200g Ë±öËÇâÔºè„Å´„Çì„Å´„Åè 1Áâá Á≠âÔºâ
_QTY_IN_NAME_RE = re.compile(
    r'(?:^|\s)('
    r'(?:Â∞è„Åï„Åò|Â§ß„Åï„Åò)\s*\d+(?:\.\d+)?'
    r'|(?:\d+(?:\.\d+)?)\s*(?:g|„Ç∞„É©„É†|kg|„éè|ml|mL|L|cc|„Ç´„ÉÉ„Éó|cup|ÂÄã|Áâá|Êûö|Êú¨)'
    r'|Â∞ë„ÄÖ|ÈÅ©Èáè'
    r')(?=\s|$)'
)

def split_quantity_from_name(name: str) -> tuple[str, Optional[str]]:
    txt = name or ""
    m = _QTY_IN_NAME_RE.search(txt)
    qty = m.group(1) if m else None
    base = _QTY_IN_NAME_RE.sub(" ", txt).strip()
    base = re.sub(r'\s{2,}', ' ', base)
    return (base or txt), qty

def sanitize_amount(amount: Optional[str]) -> Optional[str]:
    if not amount:
        return None
    a = amount.strip().replace("Ôºé", ".").replace(".0", "")
    if a in {"Â∞è„Åï„Åò0", "Â§ß„Åï„Åò0", "0g", "0ÂÄã", "0Áâá", "0Êûö", "0Êú¨", "0cc"}:
        return "Â∞ë„ÄÖ"
    return a

def normalize_ingredients(ings: List[Ingredient], servings: int) -> List[Ingredient]:
    fixed: List[Ingredient] = []
    for it in ings:
        base_name, qty_in_name = split_quantity_from_name(it.name)
        amt = sanitize_amount(getattr(it, "amount", None)) or qty_in_name or ""
        if (not amt) or ("ÈÅ©Èáè" in amt) or (not _has_number(amt) and "Â∞ë„ÄÖ" not in amt):
            amt = _guess_amount(base_name, servings)
        amt = sanitize_amount(amt) or "ÈÅ©Èáè"
        fixed.append(Ingredient(
            name=base_name,
            amount=amt,
            is_optional=getattr(it, "is_optional", False),
            substitution=getattr(it, "substitution", None),
        ))
    return fixed

# ============================================================
# „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£ÔºöÂô®ÂÖ∑Êé®ÂÆöÔºàÊùêÊñô/ÊâãÈ†Ü„Åã„ÇâÔºâ
# ============================================================
_TOOL_RULES = [
    (r"(Âàá„Çã|Âàª„ÇÄ|„Åø„Åò„Çì|ÂçÉÂàá„Çä|Ëº™Âàá„Çä|„Åù„ÅéÂàá„Çä)", ["ÂåÖ‰∏Å", "„Åæ„Å™Êùø"]),
    (r"(Ê∑∑„Åú|Âíå„Åà|„Åª„Åê„Åó|Ê∫∂„ÅçÂçµ|Ë°£„Çí‰Ωú„Çã)", ["„Éú„Ç¶„É´", "ËèúÁÆ∏"]),
    (r"(ÁÇí„ÇÅ|ÁÑº„ÅçËâ≤|„ÇΩ„ÉÜ„Éº|È¶ô„Çä„ÅåÁ´ã„Å§„Åæ„Åß)", ["„Éï„É©„Ç§„Éë„É≥", "„Éï„É©„Ç§Ëøî„Åó"]),
    (r"(ÁÑº„Åè|„Éà„Éº„Çπ„Éà|„Ç∞„É™„É´)", ["„Ç™„Éº„Éñ„É≥/„Éà„Éº„Çπ„Çø„Éº", "Â§©ÊùøÔºà„Ç¢„É´„Éü„Éõ„Ç§„É´Ôºâ"]),
    (r"(Ëåπ„Åß|„ÇÜ„Åß|ÊπØ„Åå|‰∏ãËåπ„Åß)", ["ÈçãÔºàÊπØÁî®Ôºâ", "„Ç∂„É´"]),
    (r"(ÁÖÆ|ÁÖÆËæº|ÁÖÆÁ´ã|Âº±ÁÅ´„Åß|‰∏≠ÁÅ´„Åß|Ê≤∏È®∞)", ["Èçã", "ËèúÁÆ∏"]),
    (r"(Ëí∏„Åó|Ëí∏Ê∞ó|Ëí∏„ÅóÂô®)", ["Ëí∏„ÅóÂô®Ôºà„Åæ„Åü„ÅØÈçãÔºãËí∏„ÅóÂè∞Ôºâ", "Ëìã"]),
    (r"(Êèö„Åí|Á¥†Êèö„Åí|Ê≤π„Åß)", ["ÈçãÔºàÊèö„ÅíÁâ©Áî®Ôºâ", "Ê≤πÊ∏©Ë®à", "Á∂≤„Åò„ÇÉ„Åè„Åó"]),
    (r"(ÈõªÂ≠ê„É¨„É≥„Ç∏|„É¨„É≥„Ç∏|600W|500W)", ["ÈõªÂ≠ê„É¨„É≥„Ç∏", "ËÄêÁÜ±ÂÆπÂô®", "„É©„ÉÉ„Éó"]),
    (r"(ÁÇä„Åè|„ÅîÈ£Ø|Á±≥„ÇíÁ†î„Åê|ÁÇäÈ£Ø)", ["ÁÇäÈ£ØÂô®", "„Éú„Ç¶„É´ÔºàÁ±≥Á†î„ÅéÔºâ"]),
    (r"(ÁöÆ„Çí„ÇÄ„Åè|„Åô„Çä„Åä„Çç|„Åä„Çç„Åó)", ["„Éî„Éº„É©„Éº/„Åä„Çç„ÅóÈáë"]),
    (r"(„Åì„Åô|Êøæ„Åô|Êºâ„Åô)", ["„Åì„ÅóÂô®Ôºà„Åæ„Åü„ÅØ„Ç∂„É´Ôºâ"]),
]
_MEASURE_RE = re.compile(r"(Â∞è„Åï„Åò|Â§ß„Åï„Åò|„Ç´„ÉÉ„Éó|cup|cc|ml|mL|L|‚Ñì)")

def infer_tools_from_text(ingredients_text: str, steps_text: str) -> List[str]:
    txt = f"{ingredients_text}\n{steps_text}"
    tools: List[str] = []
    for pattern, add_list in _TOOL_RULES:
        if re.search(pattern, txt):
            for t in add_list:
                if t not in tools:
                    tools.append(t)
    if _MEASURE_RE.search(txt):
        for t in ["Ë®àÈáè„Çπ„Éó„Éº„É≥", "Ë®àÈáè„Ç´„ÉÉ„Éó"]:
            if t not in tools:
                tools.append(t)
    if not tools:
        tools = ["ÂåÖ‰∏Å", "„Åæ„Å™Êùø", "„Éú„Ç¶„É´", "„Éï„É©„Ç§„Éë„É≥„Åæ„Åü„ÅØÈçã", "Ë®àÈáè„Çπ„Éó„Éº„É≥"]
    return tools

def infer_tools_from_recipe(rec: Recipe) -> List[str]:
    ings_txt = "„ÄÅ".join([i.name for i in rec.ingredients])
    steps_txt = "„ÄÇ".join([s.text for s in rec.steps])
    return infer_tools_from_text(ings_txt, steps_txt)

# ============================================================
# „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£ÔºöÂìÅË≥™„ÉÅ„Çß„ÉÉ„ÇØÔºà‚úÖ„ÅÆ„ÅøË°®Á§∫Áî®Ôºâ
# ============================================================
HEAT_WORDS = ["Âº±ÁÅ´", "‰∏≠ÁÅ´", "Âº∑ÁÅ´", "Ê≤∏È®∞", "‰ΩôÁÜ±", "„Ç™„Éº„Éñ„É≥", "„É¨„É≥„Ç∏"]
SEASONINGS = ["Â°©", "Á†ÇÁ≥ñ", "„Åó„Çá„ÅÜ„ÇÜ", "ÈÜ§Ê≤π", "„Åø„Çä„Çì", "ÈÖí", "Âë≥Âôå", "ÈÖ¢", "„Åî„ÅæÊ≤π", "„Ç™„É™„Éº„Éñ„Ç™„Ç§„É´", "„Éê„Çø„Éº", "„Å†„Åó"]

def quality_check(rec) -> tuple[bool, List[str]]:
    warns: List[str] = []
    if len(getattr(rec, "ingredients", []) or []) < 3:
        warns.append("ÊùêÊñô„ÅåÂ∞ë„Å™„Åô„Åé„Åæ„ÅôÔºà3ÂìÅ‰ª•‰∏ä„ÇíÊé®Â•®Ôºâ")
    if len(getattr(rec, "steps", []) or []) < 3:
        warns.append("ÊâãÈ†Ü„ÅåÂ∞ë„Å™„Åô„Åé„Åæ„ÅôÔºà3„Çπ„ÉÜ„ÉÉ„Éó‰ª•‰∏ä„ÇíÊé®Â•®Ôºâ")

    step_text = "„ÄÇ".join([getattr(s, "text", "") for s in (rec.steps or [])])
    if not any(w in step_text for w in HEAT_WORDS):
        warns.append("ÁÅ´Âä†Ê∏õ„ÇÑÂä†ÁÜ±„ÅÆË®òËø∞„Åå„ÅÇ„Çä„Åæ„Åõ„ÇìÔºàÂº±ÁÅ´/‰∏≠ÁÅ´/Âº∑ÁÅ´ „ÇÑ „É¨„É≥„Ç∏ÊôÇÈñì„ÅÆÊòéÁ§∫„ÇíÊé®Â•®Ôºâ")

    ing_txt = "„ÄÅ".join([f"{getattr(i, 'name', '')} {getattr(i, 'amount', '')}" for i in (rec.ingredients or [])])
    if not any(s in ing_txt for s in SEASONINGS):
        warns.append("Âü∫Êú¨ÁöÑ„Å™Ë™øÂë≥„ÅåË¶ãÂΩì„Åü„Çä„Åæ„Åõ„ÇìÔºàÂ°©„Éª„Åó„Çá„ÅÜ„ÇÜ„Éª„Åø„Çä„ÇìÁ≠âÔºâ")
    if "ÈÅ©Èáè" in ing_txt:
        warns.append("‚ÄúÈÅ©Èáè‚Äù„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„ÅôÔºà„Åß„Åç„Çã„Å†„ÅëÂ∞è„Åï„Åò/Â§ß„Åï„Åò/„Ç∞„É©„É†Ë°®Ë®ò„Å´Ôºâ")

    ok = (len(warns) == 0)
    return ok, warns

def _filter_passed_recipes(recommendations: List[Recipe]) -> List[Recipe]:
    passed = []
    for r in recommendations:
        ok, _ = quality_check(r)
        if ok:
            passed.append(r)
    return passed

# ============================================================
# üî• Ê†ÑÈ§ä„Éó„É≠„Éï„Ç°„Ç§„É´ & Ê¶ÇÁÆó„É≠„Ç∏„ÉÉ„ÇØÔºà„Åì„Åì„Åã„ÇâÊñ∞Ë¶èËøΩÂä†Ôºâ
# ============================================================
NUTRI_PROFILES = {
    "„Åµ„Å§„ÅÜ":   {"kcal": (500, 800), "protein_g": (20, 35), "salt_g": (0, 2.5)},
    "„ÉÄ„Ç§„Ç®„ÉÉ„Éà": {"kcal": (350, 600), "protein_g": (25, 40), "salt_g": (0, 2.0)},
    "„Åå„Å£„Å§„Çä": {"kcal": (700,1000), "protein_g": (35, 55), "salt_g": (0, 3.0)},
    "Ê∏õÂ°©":     {"kcal": (500, 800), "protein_g": (20, 35), "salt_g": (0, 2.0)},
}

FOODS = {
    # „Åü„Çì„Å±„ÅèÊ∫êÔºà100gÔºâ
    "È∂è„ÇÄ„Å≠ËÇâ": {"kcal":120, "protein_g":23, "fat_g":2,  "carb_g":0,  "salt_g":0},
    "È∂è„ÇÇ„ÇÇËÇâ": {"kcal":200, "protein_g":17, "fat_g":14, "carb_g":0,  "salt_g":0},
    "Ë±öËÇâ":     {"kcal":242, "protein_g":20, "fat_g":19, "carb_g":0,  "salt_g":0},
    "ÁâõËÇâ":     {"kcal":250, "protein_g":20, "fat_g":19, "carb_g":0,  "salt_g":0},
    "„Å≤„ÅçËÇâ":   {"kcal":230, "protein_g":19, "fat_g":17, "carb_g":0,  "salt_g":0},
    "ÈÆ≠":       {"kcal":200, "protein_g":22, "fat_g":12, "carb_g":0,  "salt_g":0},
    "Êú®Á∂øË±ÜËÖê": {"kcal":72,  "protein_g":7,  "fat_g":4,  "carb_g":2,  "salt_g":0},
    "Áµπ„Åî„ÅóË±ÜËÖê":{"kcal":56, "protein_g":5,  "fat_g":3,  "carb_g":2,  "salt_g":0},

    # ÈáéËèúÔºà100gÔºâ
    "„Ç≠„É£„Éô„ÉÑ": {"kcal":23, "protein_g":1, "fat_g":0, "carb_g":5, "salt_g":0},
    "Áéâ„Å≠„Åé":   {"kcal":37, "protein_g":1, "fat_g":0, "carb_g":9, "salt_g":0},
    "„Å´„Çì„Åò„Çì": {"kcal":37, "protein_g":1, "fat_g":0, "carb_g":9, "salt_g":0},
    "„Åò„ÇÉ„Åå„ÅÑ„ÇÇ":{"kcal":76,"protein_g":2, "fat_g":0, "carb_g":17,"salt_g":0},
    "„Å™„Åô":     {"kcal":22, "protein_g":1, "fat_g":0, "carb_g":5, "salt_g":0},
    "„ÇÇ„ÇÑ„Åó":   {"kcal":14, "protein_g":2, "fat_g":0, "carb_g":3, "salt_g":0},

    # ‰∏ªÈ£üÔºà100gÔºâ
    "„ÅîÈ£Ø":     {"kcal":168,"protein_g":2.5,"fat_g":0.3,"carb_g":37,"salt_g":0},

    # Ë™øÂë≥ÊñôÔºà1Â§ß„Åï„ÅòÁõ∏ÂΩìÔºâ
    "„Åó„Çá„ÅÜ„ÇÜ": {"kcal":13, "protein_g":1.4,"fat_g":0,"carb_g":1.2,"salt_g":2.6},
    "„Åø„Çä„Çì":   {"kcal":43, "protein_g":0,"fat_g":0,"carb_g":7.2,"salt_g":0},
    "ÈÖí":       {"kcal":11, "protein_g":0,"fat_g":0,"carb_g":0.5,"salt_g":0},
    "Á†ÇÁ≥ñ":     {"kcal":35, "protein_g":0,"fat_g":0,"carb_g":9,"salt_g":0},
    "Âë≥Âôå":     {"kcal":33, "protein_g":2,"fat_g":1,"carb_g":4,"salt_g":0.9},
    "„Åî„ÅæÊ≤π":   {"kcal":111,"protein_g":0,"fat_g":12.6,"carb_g":0,"salt_g":0},
    "„Ç™„É™„Éº„Éñ„Ç™„Ç§„É´":{"kcal":111,"protein_g":0,"fat_g":12.6,"carb_g":0,"salt_g":0},
    "Â°©":       {"kcal":0,  "protein_g":0,"fat_g":0,"carb_g":0,"salt_g":6.0}, # Â∞è„Åï„Åò1=6g ‚Üí Â§ß„Åï„Åò„ÅØ√ó3„Å´Ê≥®ÊÑè
}

def amount_to_grams_or_spoons(amount: str) -> tuple[str, float]:
    """
    '200g'‚Üí('g',200), 'Â§ß„Åï„Åò1'‚Üí('tbsp',1), 'Â∞è„Åï„Åò2'‚Üí('tsp',2), '1ÂÄã'‚Üí('piece',1)
    ‰∏çÊòé„Å™„Çâ ('g', 0) „ÇíËøî„Åô
    """
    if not amount: return ("g", 0.0)
    a = amount.replace("Ôºé",".").strip().lower()
    m = re.search(r'(\d+(?:\.\d+)?)\s*(g|„Ç∞„É©„É†)', a)
    if m: return ("g", float(m.group(1)))
    m = re.search(r'Â§ß„Åï„Åò\s*(\d+(?:\.\d+)?)', a)
    if m: return ("tbsp", float(m.group(1)))
    m = re.search(r'Â∞è„Åï„Åò\s*(\d+(?:\.\d+)?)', a)
    if m: return ("tsp", float(m.group(1)))
    m = re.search(r'(\d+(?:\.\d+)?)\s*ÂÄã', a)
    if m: return ("piece", float(m.group(1)))
    m = re.search(r'(\d+(?:\.\d+)?)\s*Áâá', a)
    if m: return ("piece", float(m.group(1)) * 0.5)
    return ("g", 0.0)

def tbsp_from_tsp(x: float) -> float: return x / 3.0

def estimate_nutrition(rec) -> dict:
    """È£üÊùêÂêç„ÅÆÂåÖÂê´„Éû„ÉÉ„ÉÅ„ÅßFOODS„Åã„ÇâÊãæ„ÅÑ„ÄÅÈáè„Çíg/Â§ß„Åï„Åò/Â∞è„Åï„ÅòÁ≠â„Åã„ÇâÊ¶ÇÁÆó„ÄÇÂêàÁÆó‚Üí1‰∫∫Ââç„Å´Ââ≤„Çã„ÄÇ"""
    total = {"kcal":0.0,"protein_g":0.0,"fat_g":0.0,"carb_g":0.0,"salt_g":0.0}
    for ing in rec.ingredients:
        name = ing.name
        amt_str = ing.amount or ""
        unit, val = amount_to_grams_or_spoons(amt_str)

        key = None
        for k in FOODS.keys():
            if k in name:
                key = k; break
        if not key:
            continue

        base = FOODS[key].copy()
        factor = 0.0
        if unit == "g":
            factor = val / 100.0
        elif unit == "tbsp":
            # FOODS„ÅØ„Äå1Â§ß„Åï„Åò„ÄçÂü∫Ê∫ñ„ÅÆ„ÇÇ„ÅÆ„ÅØ val „Çí„Åù„ÅÆ„Åæ„ÅæÂÄçÁéá„Å´
            if key in ["„Åó„Çá„ÅÜ„ÇÜ","„Åø„Çä„Çì","ÈÖí","Âë≥Âôå","„Åî„ÅæÊ≤π","„Ç™„É™„Éº„Éñ„Ç™„Ç§„É´"]:
                factor = val
            else:
                factor = (val * 15.0) / 100.0
        elif unit == "tsp":
            if key in ["„Åó„Çá„ÅÜ„ÇÜ","„Åø„Çä„Çì","ÈÖí","Âë≥Âôå","„Åî„ÅæÊ≤π","„Ç™„É™„Éº„Éñ„Ç™„Ç§„É´"]:
                factor = tbsp_from_tsp(val)
            else:
                factor = (val * 5.0) / 100.0
        elif unit == "piece":
            piece_g = 0
            if "Âçµ" in name: piece_g = 50
            elif "„Å´„Çì„Å´„Åè" in name: piece_g = 5
            else: piece_g = 30
            factor = (piece_g * val) / 100.0
        else:
            continue

        for k in total:
            total[k] += base[k] * factor

    serv = max(1, getattr(rec, "servings", 1))
    for k in total:
        total[k] = round(total[k] / serv, 1)
    return total

def score_against_profile(nutri: dict, profile_name: str) -> dict:
    prof = NUTRI_PROFILES.get(profile_name, NUTRI_PROFILES["„Åµ„Å§„ÅÜ"])
    def mark(val, rng):
        lo, hi = rng
        if val < lo*0.9: return "‚ñ≥"
        if lo <= val <= hi: return "‚óé"
        if val <= hi*1.15: return "‚ñ≥"
        return "‚ö†"
    return {
        "kcal":      mark(nutri["kcal"],      prof["kcal"]),
        "protein_g": mark(nutri["protein_g"], prof["protein_g"]),
        "salt_g":    mark(nutri["salt_g"],    prof["salt_g"]),
    }
# ============================================================
# üî• Ê†ÑÈ§ä„É≠„Ç∏„ÉÉ„ÇØ „Åì„Åì„Åæ„Åß
# ============================================================

# ============================================================
# OpenAI Âëº„Å≥Âá∫„ÅóÔºàJSONÁîüÊàêÔºã„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ
# ============================================================
USE_OPENAI = True
try:
    from openai import OpenAI
    _client = OpenAI() if (USE_OPENAI and (os.getenv("OPENAI_API_KEY") or st.secrets.get("OPENAI_API_KEY"))) else None
except Exception:
    _client = None

PROMPT_TMPL = (
    "You are a helpful Japanese cooking assistant.\n"
    "Given ingredients, servings, theme, genre and max time, propose 1‚Äì3 Japanese home recipes.\n"
    "Output strict JSON matching this schema in UTF-8 (no markdown):\n"
    "{\n"
    '  "recommendations": [\n'
    "    {\n"
    '      "title": string,\n'
    '      "servings": int,\n'
    '      "total_time_min": int,\n'
    '      "difficulty": string,\n'
    '      "ingredients": [ {\n'
    '        "name": string,\n'
    '        "amount": string | null,\n'
    '        "is_optional": boolean,\n'
    '        "substitution": string | null\n'
    "      } ],\n"
    '      "steps": [ { "text": string } ],\n'
    '      "equipment": string[] | null\n'
    "    }\n"
    "  ]\n"
    "}\n"
    "Notes: Avoid vague amounts like 'ÈÅ©Èáè' when possible; prefer grams and Â§ß„Åï„Åò/Â∞è„Åï„Åò."
    " For Japanese home cooking, prefer common ratios where applicable"
    " (e.g., ÈÜ§Ê≤π:„Åø„Çä„Çì:ÈÖí ‚âà 1:1:1 for teriyaki; Âë≥ÂôåÊ±Å „Åø„Åù ‚âà 12‚Äì18g per 200ml dashi)."
    " Provide cooking times and heat levels (Âº±ÁÅ´/‰∏≠ÁÅ´/Âº∑ÁÅ´) explicitly. Avoid steps that cannot be executed in a home kitchen.\n"
)

def generate_recipes(
    ingredients: List[str],
    servings: int,
    theme: str,
    genre: str,
    max_minutes: int,
    want_keyword: str = "",
    avoid_keywords: List[str] | None = None
) -> RecipeSet:
    avoid_keywords = avoid_keywords or []

    if _client is not None:
        try:
            avoid_line = ("Èô§Â§ñ: " + ", ".join(avoid_keywords)) if avoid_keywords else "Èô§Â§ñ: „Å™„Åó"
            want_line  = ("Â∏åÊúõ: " + want_keyword) if want_keyword else "Â∏åÊúõ: „Å™„Åó"
            user_msg = (
                f"È£üÊùê: {', '.join(ingredients) if ingredients else 'ÔºàÊú™ÊåáÂÆöÔºâ'}\n"
                f"‰∫∫Êï∞: {servings}‰∫∫\n"
                f"„ÉÜ„Éº„Éû: {theme}\n„Ç∏„É£„É≥„É´: {genre}\n"
                f"ÊúÄÂ§ßË™øÁêÜÊôÇÈñì: {max_minutes}ÂàÜ\n"
                f"{want_line}\n{avoid_line}\n"
                "Ë¶Å‰ª∂:\n"
                "- Âá∫Âäõ„ÅØÂøÖ„ÅöSTRICT„Å™JSON„ÅÆ„ÅøÔºà„Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥‰∏çÂèØÔºâ\n"
                "- Èô§Â§ñ„Ç≠„Éº„ÉØ„Éº„Éâ„ÇíÂê´„ÇÄÊñôÁêÜÂêç„ÅØÁµ∂ÂØæ„Å´Âá∫„Åï„Å™„ÅÑ\n"
                "- Â∏åÊúõ„Ç≠„Éº„ÉØ„Éº„Éâ„Åå„ÅÇ„Çå„Å∞„ÄÅÂ∞ë„Å™„Åè„Å®„ÇÇ1‰ª∂„ÅØ„Åù„ÅÆË™û„Å´ÈùûÂ∏∏„Å´Ëøë„ÅÑÊñôÁêÜÂêç„Å´„Åô„Çã\n"
                "- Èáè„ÅØÂèØËÉΩ„Å™Èôê„ÇäÂÖ∑‰ΩìÔºàg, Â∞è„Åï„Åò/Â§ß„Åï„Åò/ÂÄã„ÉªÁâáÔºâ„Åß„ÄÅ‚ÄúÈÅ©Èáè‚Äù„ÅØÈÅø„Åë„Çã\n"
            )
            resp = _client.chat.completions.create(
                model="gpt-4o-mini",
                temperature=FEATURES["TEMPERATURE"],
                messages=[
                    {"role": "system", "content": PROMPT_TMPL},
                    {"role": "user", "content": user_msg},
                ],
            )
            text = resp.choices[0].message.content or "{}"
            data = json.loads(text)
            parsed = RecipeSet.model_validate(data)
            return parsed
        except Exception as e:
            st.info(f"LLM„ÅÆÊßãÈÄ†ÂåñÁîüÊàê„Å´Â§±Êïó„Åó„Åü„Åü„ÇÅ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Åó„Åæ„Åô: {e}")

    # Fallback ‚Äî ÊúÄ‰Ωé1‰ª∂
    base_ings = [Ingredient(name=x) for x in ingredients[:6]] or [Ingredient(name="È∂è„ÇÄ„Å≠ËÇâ"), Ingredient(name="„Ç≠„É£„Éô„ÉÑ")]
    steps = [
        Step(text="ÊùêÊñô„ÇíÈ£ü„Åπ„ÇÑ„Åô„ÅÑÂ§ß„Åç„Åï„Å´Âàá„Çã"),
        Step(text="„Éï„É©„Ç§„Éë„É≥„ÅßÊ≤π„ÇíÁÜ±„Åó„ÄÅËÇâ„Å®ÈáéËèú„ÇíÁÇí„ÇÅ„Çã"),
        Step(text="„Åó„Çá„ÅÜ„ÇÜ„Éª„Åø„Çä„Çì„ÉªÈÖí„ÅßÂë≥‰ªò„Åë„Åó„Å¶ÂÖ®‰Ωì„ÇíÁµ°„ÇÅ„Çã"),
    ]
    title = (want_keyword or f"„Åã„Çì„Åü„ÇìÁÇí„ÇÅÔºà{genre}È¢®Ôºâ").strip()
    rec = Recipe(
        title=title, servings=servings, total_time_min=min(20, max_minutes),
        difficulty="„Åã„Çì„Åü„Çì", ingredients=base_ings, steps=steps, equipment=None
    )
    return RecipeSet(recommendations=[rec])

# ============================================================
# UIÔºöÂÖ•Âäõ„Éï„Ç©„Éº„É†ÔºàÁîªÂÉèUI„ÅØÈùûË°®Á§∫Ôºâ
# ============================================================
with st.form("inputs", clear_on_submit=False, border=True):
    st.text_input("ÂÜ∑ËîµÂ∫´„ÅÆÈ£üÊùêÔºà„Ç´„É≥„ÉûÂå∫Âàá„ÇäÔºâ", key="ingredients", placeholder="‰æãÔºâË±öËÇâ, „Ç≠„É£„Éô„ÉÑ, „Å≠„Åé")
    c1, c2, c3 = st.columns([1, 1, 1])
    with c1:
        st.slider("‰∫∫Êï∞", 1, 6, 2, 1, key="servings")
    with c2:
        st.selectbox("„ÉÜ„Éº„Éû", ["ÊôÇÁü≠", "ÁØÄÁ¥Ñ", "Ê†ÑÈ§äÈáçË¶ñ", "Â≠ê„Å©„ÇÇÂêë„Åë", "„Åä„ÇÇ„Å¶„Å™„Åó"], index=1, key="theme")
    with c3:
        st.selectbox("„Ç∏„É£„É≥„É´", ["ÂíåÈ¢®", "Ê¥ãÈ¢®", "‰∏≠ËèØÈ¢®", "ÈüìÂõΩÈ¢®", "„Ç®„Çπ„Éã„ÉÉ„ÇØ"], index=0, key="genre")
    st.slider("ÊúÄÂ§ßË™øÁêÜÊôÇÈñìÔºàÂàÜÔºâ", 5, 90, 30, 5, key="max_minutes")

    # Â∏åÊúõ/Èô§Â§ñ„Ç≠„Éº„ÉØ„Éº„Éâ
    st.text_input("‰Ωú„Çä„Åü„ÅÑÊñôÁêÜÂêç„Éª„Ç≠„Éº„ÉØ„Éº„ÉâÔºà‰ªªÊÑèÔºâ", key="want_keyword", placeholder="‰æãÔºâÈ∫ªÂ©ÜË±ÜËÖê„ÄÅ„Éä„Çπ„Ç´„É¨„Éº")
    st.text_input("Èô§Â§ñ„Åó„Åü„ÅÑÊñôÁêÜÂêç„Éª„Ç≠„Éº„ÉØ„Éº„ÉâÔºà„Ç´„É≥„ÉûÂå∫Âàá„Çä„Éª‰ªªÊÑèÔºâ", key="avoid_keywords", placeholder="‰æãÔºâÈ∫ªÂ©ÜË±ÜËÖê, „Ç´„É¨„Éº")

    # üî• Êñ∞Ë¶èÔºöÊ†ÑÈ§ä„Éó„É≠„Éï„Ç°„Ç§„É´ÈÅ∏Êäû
    st.selectbox("Ê†ÑÈ§äÁõÆÂÆâ„Éó„É≠„Éï„Ç°„Ç§„É´", list(NUTRI_PROFILES.keys()), index=0, key="nutri_profile")

    # ÁîªÂÉèÊ©üËÉΩ„ÅØOFF„ÅÆ„Åæ„ÅæÔºàÂ∞ÜÊù•ON„Å´„Åô„ÇãÂ†¥Âêà„ÅØFEATURES„ÅßÂà∂Âæ°Ôºâ
    st.session_state["image_mode"] = "„ÉÜ„Ç≠„Çπ„Éà„ÅÆ„ÅøÔºàÁèæÂú®„ÅÆ„Åæ„ÅæÔºâ"
    st.session_state["image_size"] = "1024x1024"
    st.session_state["max_ai_images"] = 0

    submitted = st.form_submit_button("ÊèêÊ°à„Çí‰ΩúÊàê", use_container_width=True)

# ÈñãÁô∫ËÄÖÂêë„Åë„Éá„Éê„ÉÉ„Ç∞
if FEATURES["SHOW_DEBUG_PANEL"]:
    with st.expander("üõ† ÈñãÁô∫ËÄÖÂêë„Åë„Éá„Éê„ÉÉ„Ç∞"):
        st.write({
            "APP_MODE": APP_MODE,
            "TEMP": FEATURES["TEMPERATURE"],
            "RETRY": FEATURES["MAX_QUALITY_RETRY"],
            "KEEP_AT_LEAST_ONE": FEATURES["KEEP_AT_LEAST_ONE"],
        })

# ------------------------------------------------------------
# ÂÖ•ÂäõÊäΩÂá∫
# ------------------------------------------------------------
if not submitted:
    st.stop()

ing_text = st.session_state.get("ingredients", "") or ""
ingredients_raw = [s for s in (t.strip() for t in re.split(r"[„ÄÅ,]", ing_text)) if s]
servings = int(st.session_state.get("servings", 2))
theme = st.session_state.get("theme", "ÁØÄÁ¥Ñ")
genre = st.session_state.get("genre", "ÂíåÈ¢®")
max_minutes = int(st.session_state.get("max_minutes", 30))
want_keyword = (st.session_state.get("want_keyword") or "").strip()
avoid_keywords = [s for s in (t.strip() for t in re.split(r"[„ÄÅ,]", st.session_state.get("avoid_keywords") or "")) if s]
nutri_profile = st.session_state.get("nutri_profile","„Åµ„Å§„ÅÜ")

# ============================================================
# ÁîüÊàê ‚Üí ÂìÅË≥™„Éï„Ç£„É´„ÇøÔºà‚úÖ„ÅÆ„ÅøË°®Á§∫ÔºâÔºãËá™Âãï„É™„Éà„É©„Ç§
# ============================================================
try:
    data = generate_recipes(
        ingredients_raw, servings, theme, genre, max_minutes,
        want_keyword=want_keyword, avoid_keywords=avoid_keywords
    )
except Exception as e:
    st.error(f"„É¨„Ç∑„ÉîÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: {e}")
    st.stop()

def _contains_any(hay: str, needles: List[str]) -> bool:
    h = (hay or "").lower()
    return any(n.lower() in h for n in needles)

# 1) „Çø„Ç§„Éà„É´„ÅßÈô§Â§ñÔºàÂÆâÂÖ®ÂÅ¥Ôºâ
if avoid_keywords and data.recommendations:
    data.recommendations = [r for r in data.recommendations if not _contains_any(r.recipe_title, avoid_keywords)]

# 2) Â∏åÊúõ„Ç≠„Éº„ÉØ„Éº„ÉâÂÑ™ÂÖà
if want_keyword and data.recommendations:
    matched = [r for r in data.recommendations if want_keyword.lower() in (r.recipe_title or "").lower()]
    others  = [r for r in data.recommendations if r not in matched]
    data.recommendations = matched + others

# 3) ÂìÅË≥™„Éï„Ç£„É´„Çø & „É™„Éà„É©„Ç§
if FEATURES["ENABLE_QUALITY_FILTER"]:
    attempt = 0
    passed = _filter_passed_recipes(data.recommendations)

    while not passed and attempt < FEATURES["MAX_QUALITY_RETRY"]:
        attempt += 1
        with st.spinner(f"ÂìÅË≥™„Å´Âêà„ÅÜ„É¨„Ç∑„Éî„ÇíÂÜçÊèêÊ°à‰∏≠‚Ä¶Ôºà{attempt}/{FEATURES['MAX_QUALITY_RETRY']}Ôºâ"):
            data = generate_recipes(
                ingredients_raw, servings, theme, genre, max_minutes,
                want_keyword=want_keyword, avoid_keywords=avoid_keywords
            )
            # Èô§Â§ñ„Å®Â∏åÊúõ„ÅÆÈÅ©Áî®„ÇíÊØéÂõû„Åã„Åë„Çã
            if avoid_keywords and data.recommendations:
                data.recommendations = [r for r in data.recommendations if not _contains_any(r.recipe_title, avoid_keywords)]
            if want_keyword and data.recommendations:
                matched = [r for r in data.recommendations if want_keyword.lower() in (r.recipe_title or "").lower()]
                others  = [r for r in data.recommendations if r not in matched]
                data.recommendations = matched + others

            passed = _filter_passed_recipes(data.recommendations)

    if passed:
        data.recommendations = passed
    else:
        if FEATURES["KEEP_AT_LEAST_ONE"] and data.recommendations:
            data.recommendations = [data.recommendations[0]]
            st.info("ÂìÅË≥™Âü∫Ê∫ñ„ÇíÊ∫Ä„Åü„ÅôÂÄôË£ú„ÅåË¶ã„Å§„Åã„Çâ„Å™„Åã„Å£„Åü„Åü„ÇÅ„ÄÅÂèÇËÄÉ„Å®„Åó„Å¶1‰ª∂„Å†„ÅëË°®Á§∫„Åó„Åæ„Åô„ÄÇ")
        else:
            st.error("ÂìÅË≥™Âü∫Ê∫ñ„ÇíÊ∫Ä„Åü„Åô„É¨„Ç∑„Éî„ÇíÁîüÊàê„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇÊù°‰ª∂„ÇíÂ∞ë„ÅóÁ∑©„ÇÅ„Å¶ÂÜçÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ")
            st.stop()

# ============================================================
# Ë°®Á§∫Ôºà‚úÖ„ÅÆ„Åø„Éê„ÉÉ„Ç∏Ë°®Á§∫ÔºèNG„ÅØ„Åù„ÇÇ„Åù„ÇÇÊÆã„Å£„Å¶„ÅÑ„Å™„ÅÑÊÉ≥ÂÆöÔºâÔºã Ê†ÑÈ§äÊ¶ÇÁÆó
# ============================================================
if not data or not data.recommendations:
    st.warning("ÂÄôË£ú„Åå‰ΩúÊàê„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇÂÖ•Âäõ„ÇíË¶ãÁõ¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")
    st.stop()

for rec in data.recommendations:
    # Ë°®Á§∫Ââç„ÅÆÊ≠£Ë¶èÂåñÔºÜÂô®ÂÖ∑Ë£úÂÆå
    rec.ingredients = normalize_ingredients(rec.ingredients, rec.servings)
    tools = rec.equipment or infer_tools_from_recipe(rec)

    st.divider()
    st.subheader(rec.recipe_title)

    # ÂìÅË≥™„Éê„ÉÉ„Ç∏ÔºàOK„ÅÆÊôÇ„Å†„ÅëÔºâ
    ok, _warns = quality_check(rec)
    if ok:
        st.success("‚úÖ ‰∏ÄËà¨ÁöÑ„Å™ÂÆ∂Â∫≠ÊñôÁêÜ„Å®„Åó„Å¶Â¶•ÂΩì„Å™ÂìÅË≥™„Åß„Åô")

    colA, colB = st.columns([2, 1])
    with colA:
        meta = []
        meta.append(f"**‰∫∫Êï∞:** {rec.servings}‰∫∫ÂàÜ")
        if rec.total_time_min:
            meta.append(f"**ÁõÆÂÆâ:** {rec.total_time_min}ÂàÜ")
        if rec.difficulty:
            meta.append(f"**Èõ£ÊòìÂ∫¶:** {rec.difficulty}")
        st.markdown(" / ".join(meta))

        st.markdown("**Âô®ÂÖ∑:** " + ("„ÄÅ".join(tools) if tools else "Áâπ„Å´„Å™„Åó"))

        # üî• Ê†ÑÈ§äÊ¶ÇÁÆó & „Çπ„Ç≥„Ç¢Ë°®Á§∫Ôºà1‰∫∫ÂâçÔºâ
        nutri = estimate_nutrition(rec)
        score = score_against_profile(nutri, nutri_profile)
        col_n1, col_n2 = st.columns([1,2])
        with col_n1:
            st.markdown("**Ê†ÑÈ§ä„ÅÆÊ¶ÇÁÆóÔºà1‰∫∫ÂâçÔºâ**")
            st.write(
                f"- „Ç®„Éç„É´„ÇÆ„Éº: {nutri['kcal']} kcalÔºà{score['kcal']}Ôºâ\n"
                f"- „Åü„Çì„Å±„ÅèË≥™: {nutri['protein_g']} gÔºà{score['protein_g']}Ôºâ\n"
                f"- ËÑÇË≥™: {nutri['fat_g']} g\n"
                f"- ÁÇ≠Ê∞¥ÂåñÁâ©: {nutri['carb_g']} g\n"
                f"- Â°©ÂàÜ: {nutri['salt_g']} gÔºà{score['salt_g']}Ôºâ"
            )
        with col_n2:
            tips = []
            if score["salt_g"] == "‚ö†":
                tips.append("Â°©ÂàÜ„ÅåÂ§ö„ÇÅ ‚Üí „Åó„Çá„ÅÜ„ÇÜ/Âë≥Âôå„ÇíÂ∞è„Åï„Åò1/2Ê∏õ„Çâ„Åô„Éª„Å†„Åó„ÅßË™øÊï¥")
            if score["kcal"] == "‚ö†":
                tips.append("„Ç´„É≠„É™„ÉºÈ´ò„ÇÅ ‚Üí Ê≤π„ÇíÂ∞è„Åï„Åò1‚Üí1/2„ÄÅ‰∏ªÈ£üÈáè„ÇíÊéß„Åà„ÇÅ„Å´")
            if score["protein_g"] == "‚ñ≥":
                tips.append("„Åü„Çì„Å±„ÅèË≥™„ÇÑ„ÇÑ‰∏çË∂≥ ‚Üí Âçµ„ÇÑË±ÜËÖê„Çí1ÂìÅËøΩÂä†")
            if tips:
                st.info("**‰∏ÄË®Ä„Ç¢„Éâ„Éê„Ç§„Çπ**\n- " + "\n- ".join(tips))

        st.markdown("**ÊùêÊñô**")
        for i in rec.ingredients:
            base, qty_in_name = split_quantity_from_name(i.name)
            amt = sanitize_amount(getattr(i, "amount", None)) or qty_in_name or "ÈÅ©Èáè"
            st.markdown(
                f"- {base} {amt}"
                + ("Ôºà‰ªªÊÑèÔºâ" if i.is_optional else "")
                + (f" / ‰ª£Êõø: {i.substitution}" if i.substitution else "")
            )

        st.markdown("**ÊâãÈ†Ü**")
        for idx, s in enumerate(rec.steps, 1):
            st.markdown(f"**STEP {idx}**„ÄÄ{strip_step_prefix(s.text)}")

    with colB:
        # ÁîªÂÉèÊ©üËÉΩ„ÅØOFF
        pass

# „Åì„Åì„Åæ„Åß
